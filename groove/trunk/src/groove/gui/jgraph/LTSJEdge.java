package groove.gui.jgraph;

import groove.graph.Edge;
import groove.gui.look.Look;
import groove.gui.look.VisualKey;
import groove.io.HTMLConverter;
import groove.lts.GTS;
import groove.lts.GraphTransition;
import groove.lts.RuleTransition;
import groove.util.Groove;

/**
 * JEdge class that describes the underlying edge as a graph transition.
 * @author Arend Rensink
 * @version $Revision $
 */
public class LTSJEdge extends AJEdge<GTS,LTSJGraph,LTSJModel,LTSJVertex>
        implements LTSJCell {
    /**
     * Constructs an uninitialised instance.
     * Call {@link #setJModel(JModel)} to initialise.
     */
    private LTSJEdge() {
        super();
    }

    @Override
    protected void initialise() {
        super.initialise();
        this.visibleFlag = true;
    }

    @Override
    public boolean isCompatible(Edge edge) {
        return super.isCompatible(edge)
            && isPartial() == ((GraphTransition) edge).isPartial();
    }

    @Override
    public void addEdge(Edge edge) {
        super.addEdge(edge);
        // updates the look on the basis of the edge
        setLook(Look.TRANSIENT, isPartial());
        setLook(Look.ABSENT, isAbsent());
    }

    @Override
    public GraphTransition getEdge() {
        return (GraphTransition) super.getEdge();
    }

    @Override
    StringBuilder getEdgeKindDescription() {
        return new StringBuilder("transition");
    }

    @Override
    String getLabelDescription() {
        StringBuffer result = new StringBuffer(", generated by ");
        String[] displayedLabels = new String[getEdges().size()];
        int labelIndex = 0;
        for (Object part : getEdges()) {
            RuleTransition trans = (RuleTransition) part;
            String description;
            if (getJGraph().isShowAnchors()) {
                description = trans.getEvent().toString();
            } else {
                description = trans.getEvent().getRule().getFullName();
            }
            displayedLabels[labelIndex] =
                HTMLConverter.STRONG_TAG.on(description, true);
            labelIndex++;
        }
        if (displayedLabels.length == 1) {
            result.append(displayedLabels[0]);
        } else {
            result.append(Groove.toString(displayedLabels, "<br>- ", "",
                "<br>- "));
        }
        return result.toString();
    }

    /** Indicates that this edge is active. */
    final boolean isActive() {
        return getLooks().contains(Look.ACTIVE);
    }

    /** Indicates that the node or target of this edge is absent. */
    final boolean isAbsent() {
        return getEdge().source().isAbsent() || getEdge().target().isAbsent();
    }

    /** Indicates that this edge is a partial rule application. */
    final boolean isPartial() {
        boolean result = true;
        for (Edge trans : getEdges()) {
            if (!((GraphTransition) trans).isPartial()) {
                result = false;
                break;
            }
        }
        return result;
    }

    public void setVisibleFlag(boolean visible) {
        this.visibleFlag = visible;
        setStale(VisualKey.VISIBLE);
    }

    public boolean hasVisibleFlag() {
        return this.visibleFlag;
    }

    /** Changes the active status of this edge.
     * @return {@code true} if the active status changed as a result of this call.
     */
    public final boolean setActive(boolean active) {
        return setLook(Look.ACTIVE, active);
    }

    @Override
    protected Look getStructuralLook() {
        return Look.TRANS;
    }

    private boolean visibleFlag;

    /** Constructs a fresh instance.
     * Call {@link #setJModel(JModel)} to initialise.
     */
    public static LTSJEdge newInstance() {
        return new LTSJEdge();
    }
}