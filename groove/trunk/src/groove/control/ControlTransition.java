/* GROOVE: GRaphs for Object Oriented VErification * Copyright 2003--2007 University of Twente * * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,  * either express or implied. See the License for the specific  * language governing permissions and limitations under the License. * * $Id: ControlTransition.java,v 1.10 2008-01-30 11:13:57 fladder Exp $ */package groove.control;import groove.graph.BinaryEdge;import groove.graph.DefaultLabel;import groove.graph.Edge;import groove.graph.Element;import groove.graph.Label;import groove.graph.Node;import groove.trans.Rule;import java.util.HashSet;import java.util.Set;/** *  * @author Staijen *  * Represents a transition in a control automaton, which is unique by its * source, target and associated Rule. *  * This is a DefaultEdge to be able to visualize as GraphShape, and a * LocationTransition to use for explocation. */public class ControlTransition implements BinaryEdge, LocationTransition {	private ControlState source;    private ControlState target;	    /** the main label of the rule, can be null **/    private String label;          /** the failure set of the rules, can be empty **/	private Set<String> failures;		private ControlTransition visibleParent;	/**	 * 	 * Creates a labelled controltransition between two controlstates	 * 	 * @param source	 * 	 * @param target	 * 	 * @param label	 *            is the Rule associated with this transition	 * 	 */	/** Creates a new ControLTransition with a label and a failureset **/	public ControlTransition(ControlState source, ControlState target, String label, Set<String> failures) {		this.source = source;		this.target = target;		this.label = label;		this.failures = failures;	}		/** creates a new ControlTransition with a label (empty failureset) **/ 	public ControlTransition(ControlState source, ControlState target, String label) {		this(source, target, label, new HashSet<String>());	}	/** creates a new ControlTransition without label and empty failureset (i.e. lambda-transition) **/	public ControlTransition(ControlState source, ControlState target ) {		this(source, target, null, new HashSet<String>());	}		/** creates a new ControlTransition with no label and the given failureset **/ 	public ControlTransition(ControlState source, ControlState target, Set<String> failures ) {		this(source, target, null, failures);	}		/** Returns the text on the label */	public String getText() {		String retval = null;		if( hasFailures() ) {			retval = this.failures.toString();		}		if( label != null ) {			if( retval != null )				retval += " ";			else				retval = "";						retval += label;		}		if( retval == null ) {			retval = "__LAMBDA__";		}		return retval;	}	public Label label() {		return DefaultLabel.createLabel(this.getText());	}	public ControlState source() {		return source;	}	public ControlState target() {		return target;	}	public Node end(int i) {		return null;	}	public int endCount() {		return 0;	}	public int endIndex(Node node) {		return 0;	}	public Node[] ends() {		return new Node[] { target() };	}	public boolean hasEnd(Node node) {		return false;	}	public Node opposite() {		return target();	}	public int compareTo(Element obj) {		if (obj instanceof ControlState) {			// for states, we just need to look at the source of this transition			if (source().equals(obj)) {				return +1;			} else {				return source().compareTo(obj);			}		} else {			Edge other = (Edge) obj;			if (!source().equals(other.source())) {				return source().compareTo(other.source());			}			// for other edges, first the end count, then the label, then the		// other ends			if (endCount() != other.endCount()) {				return endCount() - other.endCount();			}			if (!label().equals(other.label())) {				return label().compareTo(other.label());			}			for (int i = 1; i < endCount(); i++) {				if (!end(i).equals(other.end(i))) {					return end(i).compareTo(other.end(i));				}			}			return 0;		}	}	/**	 * 	 * Some control transitions are not visible in the control automaton.	 * @param parent the representing and visible parent element	 * 	 */	public void setVisibleParent(ControlTransition parent) {		this.visibleParent = parent;	}	/**	 * Some control transitions are not visible in the control automaton.	 * @return the representing and visible parent element	 */	public ControlTransition getVisibleParent() {		return this.visibleParent;	}	/**	 * Modify the source. Ment to be used for merging states only.	 * @param source	 */	public void setSource(ControlState source) {		this.source = source;	}	/**	 * 	 * Modify the target. Ment to be used for merging states only.	 * 	 * @param target	 * 	 */	public void setTarget(ControlState target) {		this.target = target;	}	@Override	public String toString() {		return this.source + "--- " + getText() + " --->" + this.target;	}	/**	 * to store the shape the transition is stored in, for removing purposes	 */	private ControlShape parent;	/**	 * Setter for parent;	 * @param parent	 */	public void setParent(ControlShape parent) {		this.parent = parent;	}	/**	 * Getter for parent;	 * @return ControlShape	 */	public ControlShape getParent() {		return this.parent;	}	public void setFailureFromInit(ControlState state) {		this.failures.addAll(state.getInit());	}		/** returns the set of string values of the failures **/	public Set<String> getFailures() { 		return failures;	}		/**	 * Set of rules representing the failure-set of this transition	 * @param rules	 */	public void setFailureSet(Set<Rule> rules) {		this.rules = rules;	}	/**	 * @return the concrete failure-set of this transition (set of rules)	 */	public Set<Rule> getFailureSet() {		return rules;	}	private Set<Rule> rules;		private Rule rule;		/** set rule corresponding to label **/	public void setRule(Rule rule) {		this.rule = rule;	}		/** get Rule corresponding to label **/	public Rule getRule() {		return this.rule;	}			public boolean isLambda() {		return( label == null && failures.isEmpty());	}		public boolean hasFailures() {		return !failures.isEmpty();	}		public boolean hasLabel() {		return !(label == null);	}		public String getLabel() {		return label;	}		}