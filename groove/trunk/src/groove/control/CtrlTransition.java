/* * GROOVE: GRaphs for Object Oriented VErification *  * Copyright 2003--2007 University of Twente *  *  *  * Licensed under the Apache License, Version 2.0 (the "License"); *  * you may not use this file except in compliance with the License. *  * You may obtain a copy of the License at *  * http://www.apache.org/licenses/LICENSE-2.0 *  *  *  * Unless required by applicable law or agreed to in writing, *  * software distributed under the License is distributed on an *  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, *  * either express or implied. See the License for the specific *  * language governing permissions and limitations under the License. *  *  *  * $Id: ControlTransition.java,v 1.10 2008-01-30 11:13:57 fladder Exp $ */package groove.control;import groove.graph.AbstractEdge;import groove.trans.Rule;import groove.trans.RuleSystem;import groove.util.Fixable;import groove.view.FormatError;import groove.view.FormatException;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.Set;import java.util.TreeSet;/** * Represents a transition in a control automaton. * Control transitions have pairs of guards and rule calls as labels. * A rule call is a rule with a sequence of input and output parameters. * A guard is a failure set, i.e., a set of rules that cannot be performed. * @author Arend Rensink */public class CtrlTransition extends AbstractEdge<CtrlState,CtrlLabel,CtrlState>        implements Fixable {    /**     * Creates a new control transition between two control states.     */    public CtrlTransition(CtrlState source, String ruleName, CtrlState target) {        super(source, CtrlLabel.DUMMY_LABEL, target);        this.ruleName = ruleName;    }    /**     * Creates a new control transition between two control states.     */    private CtrlTransition(CtrlState source, CtrlLabel label, CtrlState target) {        super(source, label, target);        this.ruleName = label.getRule().getName().text();        this.guard = label.getGuard();        this.parameters = label.getParameters();    }    /**     * Sets the guard to a given (non-{@code null}) set of failure rule names.     * The guard should be set only once.      */    public void setGuard(Set<String> guard) {        assert this.guard == null && guard != null;        testFixed(false);        this.guard = guard;    }    /** Returns the current guard, as a set of failure rule names. */    private Set<String> getGuard() {        return this.guard;    }    /**     * Sets the guard to a given (non-{@code null}) set of failure rule names.     * The guard should be set only once.      */    public void setParameters(List<CtrlPar> parameters) {        assert this.parameters == null && parameters != null;        testFixed(false);        this.parameters = parameters;    }    /** Returns the list of parameters. */    private List<CtrlPar> getParameters() {        return this.parameters;    }    /**     * Tests if this transition is an else transition. This is the case if the     * failure set is non-empty.     */    public boolean hasFailures() {        return !this.guard.isEmpty();    }    /** Returns the string label of this transition. */    public String getLabel() {        return this.ruleName;    }    /** the main label of the rule; can be <code>null</code>. */    private final String ruleName;    /**     * The failure set of the transition; can be empty.     */    private Set<String> guard;    /**     * Temporary list of parameters used in this transition, without the Rule     * being known     */    private List<CtrlPar> parameters = new ArrayList<CtrlPar>();    @Override    public boolean isFixed() {        return this.fixed;    }    @Override    public void setFixed() throws FormatException {        testFixed(false);        this.fixed = true;    }    @Override    public void testFixed(boolean fixed) {        if (fixed != this.fixed) {            throw new IllegalStateException(String.format(                "Illegal manipulation is %s control label", this.fixed                        ? "fixed" : "unfixed"));        }    }    /** Flag storing whether the label has been fixed. */    private boolean fixed;    /**     * Instantiates a string-based control transition into a rule-based     * control transition, by looking up the called rule and the guard     * in a given rule system.     * @param source the new (instantiated) source state     * @param target the new (instantiated) source state     * @param rules the rule system used to      * @return the instantiated transition, where all guard and      * parameter information is encoded in the label     * @throws FormatException if the rule or one of the failures do not exist in the given rule system     */    public CtrlTransition instantiate(CtrlState source, CtrlState target,            RuleSystem rules) throws FormatException {        assert label() == null : String.format(            "Control transition %s is already instantiated", this);        List<FormatError> errors = new ArrayList<FormatError>();        Rule rule = rules.getRule(this.ruleName);        if (rule == null) {            errors.add(new FormatError("Unknown rule name %s on transition",                this.ruleName));        }        Set<Rule> ruleGuard = new TreeSet<Rule>();        if (this.guard != null) {            for (String failure : this.guard) {                Rule ruleFailure = rules.getRule(failure);                if (ruleFailure == null) {                    errors.add(new FormatError(                        "Unknown rule name %s in transition guard", failure));                } else {                    ruleGuard.add(ruleFailure);                }            }        }        List<CtrlPar> parameters = this.parameters;        if (parameters == null) {            parameters = Collections.emptyList();        }        if (!errors.isEmpty()) {            throw new FormatException(errors);        }        CtrlLabel label = new CtrlLabel(rule, parameters, ruleGuard);        return new CtrlTransition(source, label, target);    }}