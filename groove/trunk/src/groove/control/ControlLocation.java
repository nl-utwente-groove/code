package groove.control; import groove.trans.Rule;import groove.util.Pair;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.HashSet;import java.util.Iterator;import java.util.LinkedHashSet;import java.util.List;import java.util.Map;import java.util.Set;import java.util.TreeMap;/** *  * Caching implementation of the "Location" part of a GraphState * when using control.  *  * @author Tom Staijen * @version $Revision $ */public class ControlLocation implements Location {	/** 	 * Default constructor.	 * @param stateFailuresMap map from conditional control states that make up this location, 	 * to failures under which the control states are reachable	 * @param builder automaton builder to build target locations, while reusing when possible	 */	public ControlLocation(Map<ControlState, Set<Set<Rule>>> stateFailuresMap, LocationAutomatonBuilder builder) {		this.stateFailuresMap = stateFailuresMap;		this.builder = builder;	}	public Location getTarget(Rule rule, Set<Rule> failedRules) {		ExtendedLabel label = new ExtendedLabel(rule, failedRules);		ControlLocation location = transitionMap.get(label);		if (location == null) {			Set<ControlState> states = getTargetStates(rule, failedRules);			location = builder.getLocation(states);			assert location != null: "Target Location should never be null";				transitionMap.put(label, location);		}		return location;	}	/**	 * Returns the set of reachable target states, given a rule and a set of failed	 * rules.	 */	private Set<ControlState> getTargetStates(Rule rule, Set<Rule> failed) {	    if (ruleSourceStateMap == null) {	        initialise();	    }		Set<ControlState> targets = new HashSet<ControlState>();		for (ControlState state : ruleSourceStateMap.get(rule)) {			for (Set<Rule> failures : stateFailuresMap.get(state)) {				if (failed.containsAll(failures)) {					targets.addAll(state.targets(rule));					break;				}			}		}		// System.out.println("!!! Target states from " + this + " given rule "		// + rule + " and failures " + failed + ": " + targets);		return targets;	}	public Set<Rule> getDependency(Rule rule) {		if (ruleDependencyMap == null) {			initialise();		}		Set<Rule> result = ruleDependencyMap.get(rule);		if (result == null) {			ruleDependencyMap.put(rule, result = new HashSet<Rule>());		}		return result;	}		/**	 * Returns all unexplored rules that are enabled given a set of 	 * previously matched rules and a set of failed rules.	 */	public Set<Rule> getEnabledRules(Set<Rule> matched, Set<Rule> failed) {		if (alwaysEnabledRules == null) {			initialise();		}		HashSet<Rule> result = new HashSet<Rule>();		for (Rule rule : alwaysEnabledRules) {			if (!matched.contains(rule) && !failed.contains(rule)) {				result.add(rule);			}		}		for (Map.Entry<Rule, Set<Set<Rule>>> outLabelEntry : outLabelMap.entrySet()) {		    Rule rule = outLabelEntry.getKey();			if (matched.contains(rule) || failed.contains(rule)) {				// do nothing, rule is finished			} else {			    for (Set<Rule> failure: outLabelEntry.getValue()) {			        if (failed.containsAll(failure)) {			            result.add(rule);			            break;			        }			    }			}		}		return result;	}	/**	 * Returns whether the GraphState is in a success-control state, given that	 * all possible transitions have been added to the graph state, thus any 	 * rule not found in a transition has thus failed.	 * @param rules	 * 	 * FIXME: this method can be optimised if the success-states or the	 * corresponding failures are in a separate set	 * 	 * @return true if any of the "enabled" states is a success-state	 */	public boolean isSuccess(Set<Rule> rules) {		// more expensive computation, but will only be done once		for (Map.Entry<ControlState, Set<Set<Rule>>> pair : stateFailuresMap.entrySet()) {			if (pair.getKey().isSuccess()) {				if (pair.getValue().contains(EMPTY_RULE_SET)) {					return true;				} else {					for (Set<Rule> failure: pair.getValue()) {						boolean failureSucceed = true;						for (Rule rule: rules) {							if (failure.contains(rule)) {								failureSucceed = false;								break;							}						}						if (failureSucceed) {							return true;						}					}				}			}		}		return false;	}	/**	 * Initialises the various data structures.	 */	private void initialise() {	    ruleSourceStateMap = new HashMap<Rule, Set<ControlState>>();	    alwaysEnabledRules = new HashSet<Rule>();	    ruleDependencyMap = new HashMap<Rule, Set<Rule>>();	    outLabelMap = new HashMap<Rule,Set<Set<Rule>>>();		for (Map.Entry<ControlState, Set<Set<Rule>>> pair : stateFailuresMap.entrySet()) {			ControlState state = pair.getKey();			for (Rule rule : state.rules()) {				// store the source states for every rule		        Set<ControlState> sources = ruleSourceStateMap.get(rule);		        if (sources == null) {		            sources = new HashSet<ControlState>();		            ruleSourceStateMap.put(rule, sources);		        }		        sources.add(state);				// The rule is enabled				// as soon as one of its failure sets has been observed				for (Set<Rule> failure : pair.getValue()) {					Set<Rule> dependency = this.ruleDependencyMap.get(rule);					if (dependency == null) {						dependency = new HashSet<Rule>();						this.ruleDependencyMap.put(rule, dependency);					}					dependency.addAll(failure);					Set<Set<Rule>> outLabels = outLabelMap.get(rule);					if (outLabels == null) {					    outLabelMap.put(rule, outLabels = new HashSet<Set<Rule>>());					}					outLabels.add(failure);					if (failure.isEmpty()) {						alwaysEnabledRules.add(rule);					}				}			}		}	}		/** 	 * Returns an ordered list of the conditionally enabled rules in this location.	 * The ordering is a linearisation of the dependency relation: if a rule depends on 	 * another then it appears later in the list. Where the dependency does not order 	 * rules, the natural ordering is taken.	 */ 	public List<Rule> getRules() {		if (enabledRules == null) {			enabledRules = computeRuleOrdering();		}		return enabledRules;	}		/** 	 * Computes the ordered list of enabled rules from the dependency map.	 * @see #getRules()	 */ 	private List<Rule> computeRuleOrdering() {	    if (this.outLabelMap == null) {	        initialise();	    }		Set<Rule> result = new LinkedHashSet<Rule>();		Map<Rule,Set<Set<Rule>>> outLabelMap = new TreeMap<Rule,Set<Set<Rule>>>(this.outLabelMap);		while (!outLabelMap.isEmpty()) {			boolean progress = false;			Iterator<Map.Entry<Rule,Set<Set<Rule>>>> outLabelIter = outLabelMap.entrySet().iterator();			while (outLabelIter.hasNext()) {                Map.Entry<Rule, Set<Set<Rule>>> outLabelEntry = outLabelIter.next();                for (Set<Rule> failure : outLabelEntry.getValue()) {                    if (result.containsAll(failure)) {                        result.add(outLabelEntry.getKey());                        outLabelIter.remove();                        progress = true;                        break;                    }                }            }			if (!progress) {				throw new IllegalStateException("Rules have circular dependencies");			}		}		return new ArrayList<Rule>(result);	}		@Override	public String toString() {		String toString = null;		for (Map.Entry<ControlState, Set<Set<Rule>>> pair : stateFailuresMap.entrySet()) {			if (toString == null) {				toString = "";			} else {				toString += ",";			}			for (Set<Rule> failure: pair.getValue()) {				toString += failureToString(failure);			}			toString += pair.getKey().toString();		}				if( toString == null ) {			toString = "";		}				return new Integer(toString.hashCode()).toString();	}	/**	 * Generates a string representation of the contained states and corresponding enabling failures.	 * @param rules	 * @return string representation	 */	private String failureToString(Set<Rule> rules) {		String retval = "";		if (rules.size() != 0) {			retval = "![";			boolean first = true;			for (Rule rule : rules) {				if (!first)					retval += ",";				retval += rule.getName().text();				first = true;			}			retval += "]";		}		return retval;	}		private final LocationAutomatonBuilder builder;	/** 	 * Map from reachable control states to sets of failure sets through which	 * they can be reached.	 */	private final Map<ControlState, Set<Set<Rule>>> stateFailuresMap;	/** Lazily constructed map from outgoing control labels to target locations. */	private Map<ExtendedLabel, ControlLocation> transitionMap = new HashMap<ExtendedLabel, ControlLocation>();	/** List of enabled rules in this location, ordered consistently with the dependency relation. */	private List<Rule> enabledRules;	/**	 * Map from rules to control states from which the rules are enabled.	 */	private Map<Rule, Set<ControlState>> ruleSourceStateMap = new HashMap<Rule, Set<ControlState>>();	/** 	 * Labels of outgoing control transitions,	 * stored as a map from rules to their sets of enabling failures. 	 */	private Map<Rule, Set<Set<Rule>>> outLabelMap;	/** 	 * Map from conditionally applicable rules to those rules 	 * that appear in an enabling failure.	 * Thus, the image of a rule in this map is the union of its image in {@link #outLabelMap}. 	 */	private Map<Rule, Set<Rule>> ruleDependencyMap;	/** Set of unconditionally applicable rules. */	private Set<Rule> alwaysEnabledRules;		private static Set<Rule> EMPTY_RULE_SET = Collections.emptySet();	/** 	 * Class representing the labels on control transitions.	 * Labels consist of applicable rules paired with corresponding failures. 	 */	private static class ExtendedLabel extends Pair<Rule,Set<Rule>> {		/** Constructs a control label from a rule and a failure. */		public ExtendedLabel(Rule first, Set<Rule> second) {			super(first, second);		}	}}