package groove.control; import groove.trans.Rule;import groove.util.Pair;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.HashSet;import java.util.Iterator;import java.util.LinkedHashSet;import java.util.List;import java.util.Map;import java.util.Set;import java.util.TreeMap;/** *  * Caching implementation of the "Location" part of a GraphState * when using control.  *  * @author Tom Staijen * @version $Revision $ */public class ControlLocation implements Location {	/** 	 * Default constructor	 * Needs the automatonbuilder to build target locations, while reusing when possible 	 * @param builder	 */	public ControlLocation(Map<ControlState, Set<Set<Rule>>> stateFailuresMap, LocationAutomatonBuilder builder) {		this.stateFailuresMap = stateFailuresMap;		this.builder = builder;	}////	/**//	 *   The failure dependency of a state is overwritten when a failure is a subset of an already existing failure dependency.//	 *///	protected void setStates(Set<Pair<ControlState, Set<Rule>>> pairs) {//		this.states = pairs;//		for (Pair<ControlState, Set<Rule>> pair : pairs) {////			Set<Set<Rule>> sf = stateFailuresMap.get(pair.first());//			if( sf == null ) {//				sf = new HashSet<Set<Rule>>();//				stateFailuresMap.put(pair.first(), sf);//			}//			sf.add(pair.second());//		}//	}////	/**//	 * //	 * Returns the target location of a rule applied from this location,//	 * given the failing subset of the set of rules the application//	 * of rule depends on.//	 * //	 * @param rule//	 * @param failed//	 * @return target ControlLocation//	 *///	private ControlLocation getTargetLocation(Rule rule, Set<Rule> failed) {//		ControlLabel p = new Pair<Rule, Set<Rule>>(rule, failed);//		ControlLocation l = targetLocationCache.get(p);//		if (l == null) {//			Set<ControlState> states = getTargetStates(rule, failed);//			l = builder.getLocation(states);//			assert l != null: "Target Location should never be null";	//			targetLocationCache.put(p, l);//		}//		return l;//	}	public Location getTarget(Rule rule, Set<Rule> failedRules) {		ExtendedLabel label = new ExtendedLabel(rule, failedRules);		ControlLocation location = transitionMap.get(label);		if (location == null) {			Set<ControlState> states = getTargetStates(rule, failedRules);			location = builder.getLocation(states);			assert location != null: "Target Location should never be null";				transitionMap.put(label, location);		}		return location;	}	/**	 * Returns the set of reachable target states, given a rule and a set of failed	 * rules.	 */	private Set<ControlState> getTargetStates(Rule rule, Set<Rule> failed) {		Set<ControlState> targets = new HashSet<ControlState>();		for (ControlState state : ruleSourceStates.get(rule)) {			for (Set<Rule> failures : stateFailuresMap.get(state)) {				if (failed.containsAll(failures)) {					targets.addAll(state.targets(rule));					break;				}			}		}		// System.out.println("!!! Target states from " + this + " given rule "		// + rule + " and failures " + failed + ": " + targets);		return targets;	}	public Set<Rule> getDependency(Rule rule) {		if (ruleDependencyMap == null) {			initialise();		}		Set<Rule> result = ruleDependencyMap.get(rule);		if (result == null) {			ruleDependencyMap.put(rule, result = new HashSet<Rule>());		}		return result;	}		/**	 * Returns all unexplored rules that are enabled given a set of 	 * previously matched rules and a set of failed rules.	 */	public Set<Rule> getEnabledRules(Set<Rule> matched, Set<Rule> failed) {		if (alwaysEnabledRules == null) {			initialise();		}		HashSet<Rule> result = new HashSet<Rule>();		for (Rule rule : alwaysEnabledRules) {			if (!matched.contains(rule) && !failed.contains(rule)) {				result.add(rule);			}		}		for (Pair<Rule, Set<Rule>> pair : outLabelSet) {			if (matched.contains(pair.first()) || failed.contains(pair.first())) {				// do nothing, rule is finished			} else if (failed.containsAll(pair.second())) {				result.add(pair.first());			}		}		return result;	}	/**	 * Returns whether the GraphState is in a success-control state, given that	 * all possible transitions have been added to the graph state, thus any 	 * rule not found in a transition has thus failed.	 * @param rules	 * 	 * FIXME: this method can be optimised if the success-states or the	 * corresponding failures are in a separate set	 * 	 * @return true if any of the "enabled" states is a success-state	 */	public boolean isSuccess(Set<Rule> rules) {		// more expensive computation, but will only be done once		for (Map.Entry<ControlState, Set<Set<Rule>>> pair : stateFailuresMap.entrySet()) {			if (pair.getKey().isSuccess()) {				if (pair.getValue().contains(EMPTY_RULE_SET)) {					return true;				} else {					for (Set<Rule> failure: pair.getValue()) {						boolean failureSucceed = true;						for (Rule rule: rules) {							if (failure.contains(rule)) {								failureSucceed = false;								break;							}						}						if (failureSucceed) {							return true;						}					}				}			}		}		return false;	}	/**	 * Initialises the various data structures.	 */	private void initialise() {		for (Map.Entry<ControlState, Set<Set<Rule>>> pair : stateFailuresMap.entrySet()) {			ControlState state = pair.getKey();			Set<Set<Rule>> failuresSet = pair.getValue();			normaliseFailures(failuresSet);			for (Rule rule : state.rules()) {				// store the source states for every rule				addRuleSource(rule, state);				// The rule is enabled				// as soon as one of its failure sets has been observed				for (Set<Rule> failure : failuresSet) {					Set<Rule> dependency = this.ruleDependencyMap.get(rule);					if (dependency == null) {						dependency = new HashSet<Rule>();						this.ruleDependencyMap.put(rule, dependency);					}					dependency.addAll(failure);					outLabelSet.add(new ExtendedLabel(rule, failure));					if (failure.isEmpty()) {						alwaysEnabledRules.add(rule);					}				}			}		}	}		/** Removes failures that are proper supersets of others. */	private void normaliseFailures(Set<Set<Rule>> failuresSet) {		Iterator<Set<Rule>> failuresIter = failuresSet.iterator();		while (failuresIter.hasNext()) {			Set<Rule> failure = failuresIter.next();			for (Set<Rule> otherFailure: new ArrayList<Set<Rule>>(failuresSet)) {				if (failure.size() > otherFailure.size() && failure.containsAll(otherFailure)) {					// failure is a proper superset of otherFailure					failuresIter.remove();					break;				}			}		}	}	/**	 * Adds a mapping from a given rule to a control state 	 * from which this rule is applicable.	 */	private void addRuleSource(Rule rule, ControlState source) {		Set<ControlState> sources = ruleSourceStates.get(rule);		if (sources == null) {			sources = new HashSet<ControlState>();			ruleSourceStates.put(rule, sources);		}		sources.add(source);	}	/** 	 * Returns an ordered list of the conditionally enabled rules in this location.	 * The ordering is a linearisation of the dependency relation: if a rule depends on 	 * another then it appears later in the list. Where the dependency does not order 	 * rules, the natural ordering is taken.	 */ 	public List<Rule> getRules() {		if (enabledRules == null) {			enabledRules = computeRuleOrdering();		}		return enabledRules;	}		/** 	 * Computes the ordered list of enabled rules from the dependency map.	 * @see #getRules()	 */ 	private List<Rule> computeRuleOrdering() {		Set<Rule> result = new LinkedHashSet<Rule>();		Map<Rule,Set<Rule>> orderedDependencies = new TreeMap<Rule,Set<Rule>>(ruleDependencyMap);		while (!orderedDependencies.isEmpty()) {			boolean progress = false;			Iterator<Map.Entry<Rule,Set<Rule>>> orderedDependenciesIter = orderedDependencies.entrySet().iterator();			while (orderedDependenciesIter.hasNext()) {				Map.Entry<Rule,Set<Rule>> dependencyEntry = orderedDependenciesIter.next();				if (result.containsAll(dependencyEntry.getValue())) {					result.add(dependencyEntry.getKey());					orderedDependenciesIter.remove();					progress = true;					break;				}			}			if (!progress) {				throw new IllegalStateException("Rules have circular dependencies");			}		}		return new ArrayList<Rule>(result);	}		@Override	public String toString() {		String toString = null;		for (Map.Entry<ControlState, Set<Set<Rule>>> pair : stateFailuresMap.entrySet()) {			if (toString == null) {				toString = "";			} else {				toString += ",";			}			for (Set<Rule> failure: pair.getValue()) {				toString += failureToString(failure);			}			toString += pair.getKey().toString();		}				if( toString == null ) {			toString = "";		}				return new Integer(toString.hashCode()).toString();	}	/**	 * Generates a string representation of the contained states and corresponding enabling failures.	 * @param rules	 * @return string representation	 */	private String failureToString(Set<Rule> rules) {		String retval = "";		if (rules.size() != 0) {			retval = "![";			boolean first = true;			for (Rule rule : rules) {				if (!first)					retval += ",";				retval += rule.getName().text();				first = true;			}			retval += "]";		}		return retval;	}		private final LocationAutomatonBuilder builder;	/** 	 * Map from reachable control states to sets of failure sets through which	 * they can be reached.	 */	private final Map<ControlState, Set<Set<Rule>>> stateFailuresMap;	/** Lazily constructed map from outgoing control labels to target locations. */	private Map<ExtendedLabel, ControlLocation> transitionMap = new HashMap<ExtendedLabel, ControlLocation>();	/** List of enabled rules in this location, ordered consistently with the dependency relation. */	private List<Rule> enabledRules;	/**	 * Map from rules to control states from which the rules are enabled.	 */	private Map<Rule, Set<ControlState>> ruleSourceStates = new HashMap<Rule, Set<ControlState>>();	/** Set of labels of outgoing control transitions. */	private Set<ExtendedLabel> outLabelSet = new HashSet<ExtendedLabel>();	/** 	 * Map from conditionally applicable rules to those rules 	 * whose success or failure constitutes the applicability condition. 	 */	private Map<Rule, Set<Rule>> ruleDependencyMap = new HashMap<Rule, Set<Rule>>();	/** Set of unconditionally applicable rules. */	private Set<Rule> alwaysEnabledRules = new HashSet<Rule>();		private static Set<Rule> EMPTY_RULE_SET = Collections.emptySet();	/** 	 * Class representing the labels on control transitions.	 * Labels consist of applicable rules paired with corresponding failures. 	 */	private static class ExtendedLabel extends Pair<Rule,Set<Rule>> {		/** Constructs a control label from a rule and a failure. */		public ExtendedLabel(Rule first, Set<Rule> second) {			super(first, second);		}	}}