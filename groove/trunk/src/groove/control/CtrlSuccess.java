/* * GROOVE: GRaphs for Object Oriented VErification *  * Copyright 2003--2007 University of Twente *  *  *  * Licensed under the Apache License, Version 2.0 (the "License"); *  * you may not use this file except in compliance with the License. *  * You may obtain a copy of the License at *  * http://www.apache.org/licenses/LICENSE-2.0 *  *  *  * Unless required by applicable law or agreed to in writing, *  * software distributed under the License is distributed on an *  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, *  * either express or implied. See the License for the specific *  * language governing permissions and limitations under the License. *  *  *  * $Id: ControlTransition.java,v 1.10 2008-01-30 11:13:57 fladder Exp $ */package groove.control;import groove.trans.Rule;import groove.trans.RuleSystem;import groove.util.Fixable;import groove.view.FormatError;import groove.view.FormatException;import java.util.ArrayList;import java.util.LinkedHashSet;import java.util.List;import java.util.Set;import java.util.TreeSet;/** * Represents a success condition in a control automaton. * A success condition essentially consists of a guard of failure rules. * @author Arend Rensink */public class CtrlSuccess implements Fixable {    /**     * Creates a new success condition for a given source state.     */    public CtrlSuccess(CtrlState source) {        this.source = source;    }    private CtrlSuccess(CtrlState source, Set<Rule> ruleGuard) {        this.source = source;        this.ruleGuard = new LinkedHashSet<Rule>(ruleGuard);        this.guard = new LinkedHashSet<String>();        for (Rule rule : ruleGuard) {            this.guard.add(rule.getName().text());        }        setFixed();    }    /**     * Returns the source state of this success condition.     */    public final CtrlState getSource() {        return this.source;    }    private final CtrlState source;    /**     * Sets the guard to a given (non-{@code null}) set of failure rule names.     * The guard should be set only once.      */    public void setGuard(Set<String> guard) {        assert this.guard == null && guard != null;        testFixed(false);        this.guard = guard;    }    /**     * Returns the guard of this success condition, as a set of rule names.     */    public Set<String> getGuard() {        return this.guard;    }    /**     * The guard of the condition; can be empty.     */    private Set<String> guard;    /**      * Returns the set of failure rules for this success condition.     * @return the set of failure rules, or {@code null} if the condition has not yet been initialised.     */    public Set<Rule> getRuleGuard() {        return this.ruleGuard;    }    /**     * The set of failure rules of the success condition.     * Equals {@code null} if the condition has not been initialised.     */    private Set<Rule> ruleGuard;    @Override    public boolean isFixed() {        return this.fixed;    }    @Override    public void setFixed() {        testFixed(false);        this.fixed = true;    }    @Override    public void testFixed(boolean fixed) {        if (fixed != this.fixed) {            throw new IllegalStateException(String.format(                "Illegal manipulation is %s control label", this.fixed                        ? "fixed" : "unfixed"));        }    }    /** Flag storing whether the label has been fixed. */    private boolean fixed;    /**     * Instantiates a string-based success condition into a rule-based     * success condition, by looking up the guard     * in a given rule system.     * @param source the new (instantiated) source state     * @param rules the rule system used to instantiate the condition     * @return the instantiated success condition     * @throws FormatException if one of the failures does not exist in the given rule system     */    public CtrlSuccess instantiate(CtrlState source, RuleSystem rules)        throws FormatException {        testFixed(false);        List<FormatError> errors = new ArrayList<FormatError>();        this.ruleGuard = new TreeSet<Rule>();        if (this.guard != null) {            for (String failure : this.guard) {                Rule ruleFailure = rules.getRule(failure);                if (ruleFailure == null) {                    errors.add(new FormatError(                        "Unknown rule name %s in transition guard", failure));                } else {                    this.ruleGuard.add(ruleFailure);                }            }        }        if (!errors.isEmpty()) {            throw new FormatException(errors);        }        return new CtrlSuccess(source, this.ruleGuard);    }}