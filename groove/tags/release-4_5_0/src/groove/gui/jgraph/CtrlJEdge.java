package groove.gui.jgraph;

import groove.control.CtrlTransition;
import groove.graph.Edge;
import groove.gui.jgraph.JAttr.AttributeMap;
import groove.io.HTMLConverter;
import groove.lts.RuleTransition;
import groove.util.Groove;

/**
 * JEdge class that describes the underlying edge as a graph transition.
 * @author Tom Staijen
 * @version $Revision $
 */
public class CtrlJEdge extends GraphJEdge {
    /** Constructor for a prototype object. */
    CtrlJEdge(CtrlJGraph jGraph, GraphJModel<?,?> jModel) {
        super(jGraph, jModel);
    }

    /**
     * Creates a new instance from a given edge (required to be a
     * {@link RuleTransition}).
     */
    CtrlJEdge(CtrlJGraph jGraph, GraphJModel<?,?> jModel, CtrlTransition edge) {
        super(jGraph, jModel, edge);
    }

    @Override
    public CtrlJGraph getJGraph() {
        return (CtrlJGraph) super.getJGraph();
    }

    @Override
    public CtrlJEdge newJEdge(GraphJModel<?,?> jModel, Edge edge) {
        return new CtrlJEdge(getJGraph(), jModel, (CtrlTransition) edge);
    }

    @Override
    public CtrlTransition getEdge() {
        return (CtrlTransition) super.getEdge();
    }

    @Override
    public boolean addEdge(Edge edge) {
        CtrlTransition trans = (CtrlTransition) edge;
        return trans.isStart() == getEdge().isStart() && super.addEdge(edge);
    }

    @Override
    StringBuilder getEdgeKindDescription() {
        return new StringBuilder("transition");
    }

    @Override
    String getLabelDescription() {
        StringBuffer result = new StringBuffer(", generated by ");
        String[] displayedLabels = new String[getEdges().size()];
        int labelIndex = 0;
        for (Object part : getEdges()) {
            CtrlTransition trans = (CtrlTransition) part;
            String description;
            description = trans.label().text();
            displayedLabels[labelIndex] =
                HTMLConverter.STRONG_TAG.on(description, true);
            labelIndex++;
        }
        if (displayedLabels.length == 1) {
            result.append(displayedLabels[0]);
        } else {
            result.append(Groove.toString(displayedLabels, "<br>- ", "",
                "<br>- "));
        }
        return result.toString();
    }

    @Override
    protected AttributeMap createAttributes() {
        AttributeMap result;
        boolean omega = getEdge().getCall().isOmega();
        if (getEdge().isStart() && getEdge().source().isTransient()) {
            result =
                omega ? CtrlJGraph.CONTROL_OMEGA_EXIT_EDGE_ATTR
                        : CtrlJGraph.CONTROL_EXIT_EDGE_ATTR;
        } else {
            result =
                omega ? CtrlJGraph.CONTROL_OMEGA_EDGE_ATTR
                        : CtrlJGraph.CONTROL_EDGE_ATTR;
        }
        return result.clone();
    }

    /** Returns a prototype {@link CtrlJEdge} for a given {@link CtrlJGraph}. */
    public static CtrlJEdge getPrototype(CtrlJGraph jGraph) {
        return new CtrlJEdge(jGraph, null);
    }
}