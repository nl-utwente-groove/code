/* * GROOVE: GRaphs for Object Oriented VErification *  * Copyright 2003--2007 University of Twente *  *  *  * Licensed under the Apache License, Version 2.0 (the "License"); *  * you may not use this file except in compliance with the License. *  * You may obtain a copy of the License at *  * http://www.apache.org/licenses/LICENSE-2.0 *  *  *  * Unless required by applicable law or agreed to in writing, *  * software distributed under the License is distributed on an *  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, *  * either express or implied. See the License for the specific *  * language governing permissions and limitations under the License. *  *  *  * $Id: ControlTransition.java,v 1.10 2008-01-30 11:13:57 fladder Exp $ */package groove.control;import groove.control.instance.Assignment;import groove.control.instance.Step;import groove.grammar.Recipe;import groove.grammar.Rule;import groove.graph.AEdge;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.Map;import java.util.Set;/** * Represents a transition in a control automaton. * Control transitions have pairs of guards and rule calls as labels. * A rule call is a rule with a sequence of input and output parameters. * A guard is a failure set, i.e., a set of rules that cannot be performed. * A transition is <i>virtual</i> if the rule names in the call and guard * are only given as strings, and <i>actual</i> if they are instantiated rules.  * @author Arend Rensink */public class CtrlTransition extends AEdge<CtrlState,CtrlLabel> implements CtrlStep, CalledAction {    /**     * Creates a new control transition between two control states.     */    public CtrlTransition(CtrlState source, CtrlLabel label, CtrlState target) {        super(source, label.newLabel(source.getTransitions().size()), target);        this.call = label().getCall();        this.guard = label().getGuard();        this.recipe = label().getRecipe();        this.start = label().isStart();        this.number = label().getNumber();        assert source.getAut() == target.getAut();        assert guardsCorrect();    }    @Override    public int compareTo(CtrlStep o) {        int result;        if (o instanceof Step) {            result = 1;        } else {            CtrlTransition other = (CtrlTransition) o;            assert source() == other.source();            result = label().compareTo(other.label());            if (result == 0) {                result = target().getNumber() - other.target().getNumber();            }        }        return result;    }    /** Tests if all guards start in the same start state as this transition. */    private boolean guardsCorrect() {        boolean result = true;        for (CtrlTransition t : getGuard()) {            if (!t.source().equals(source())) {                result = false;                break;            }        }        return result;    }    /**      * Returns a list of indices corresponding to the transition parameters.     * For each parameter position, if the parameter is an input variable,      * the index points to the index in the source bound variables; if it is     * an output variable, it either points to the anchor position or to the     * position in the created nodes.     */    public Binding[] getCallBinding() {        if (this.callBinding == null) {            this.callBinding = computeCallBinding();        }        return this.callBinding;    }    /**     * Computes the binding of transition parameters to source variables.     * @see #getCallBinding()     */    private Binding[] computeCallBinding() {        List<CtrlPar> args = getCall().getArgs();        int size = args == null ? 0 : args.size();        Binding[] result = new Binding[size];        List<CtrlVar> sourceVars = source().getVars();        for (int i = 0; i < size; i++) {            CtrlPar arg = args.get(i);            if (arg instanceof CtrlPar.Var) {                CtrlPar.Var varArg = (CtrlPar.Var) arg;                if (arg.isInOnly()) {                    int index = sourceVars.indexOf(varArg.getVar());                    assert index >= 0;                    result[i] = Binding.var(index);                } else if (arg.isOutOnly()) {                    result[i] = null;                } else {                    assert arg.isDontCare();                    result[i] = null;                }            }        }        return result;    }    /** Binding of transition in-parameters to bound source variables. */    private Binding[] callBinding;    @Override    public List<Assignment> getFrameChanges() {        return Collections.singletonList(getAssignment());    }    /** Returns the assignment of this transition. */    public Assignment getAssignment() {        if (this.assign == null) {            this.assign = computeAssignment();        }        return this.assign;    }    /**     * Returns bindings for a list of target variables of a     * control step, using the source variables     * combined with the output parameters of the call.     */    public Assignment computeAssignment() {        List<Binding> result = new ArrayList<Binding>();        List<CtrlVar> sourceVars = source().getVars();        Map<CtrlVar,Integer> outVars = getOutVars();        for (CtrlVar var : target().getVars()) {            Integer ix = outVars.get(var);            Binding rhs;            if (ix == null) {                // the value comes from the source                int pos = sourceVars.indexOf(var);                assert pos >= 0;                rhs = Binding.var(pos);            } else {                // the value is an output parameter of the rule                Rule rule = getRule();                rhs = rule.getParBinding(ix);            }            result.add(rhs);        }        return Assignment.call(result);    }    private Assignment assign;    /** Returns the (unordered) set of variables used as input parameters in this transition. */    public Set<CtrlVar> getInVars() {        return getCall().getInVars().keySet();    }    /** Indicates that this transition has output parameters. */    public boolean hasOutVars() {        return !getCall().getOutVars().isEmpty();    }    /** Returns the set of variables used as output parameters in this transition. */    @Override    public Map<CtrlVar,Integer> getOutVars() {        return getCall().getOutVars();    }    @Override    public boolean isModifying() {        return source() != target() || hasOutVars();    }    /** Convenience method to return the control call of this transition's label. */    final public CtrlCall getCall() {        return this.call;    }    /**      * Returns the guard of this transition.     * The guard is the set of control transitions that have been tried and failed     * before this transition is tried.     */    public CtrlGuard getGuard() {        return this.guard;    }    /** Convenience method to return the called rule of this transition. */    @Override    public Rule getRule() {        return getCall().getRule();    }    /**      * Indicates whether this transition starts a new action.     */    public boolean isStart() {        return this.start;    }    /** Returns the name of the recipe of which this transition is part, if any. */    @Override    public Recipe getRecipe() {        return this.recipe;    }    /** Indicates if this control transition is part of a recipe. */    @Override    public boolean isPartial() {        return getRecipe() != null;    }    /**      * Returns the number of the transition.     * The number is unique relative to the source state.     */    public int getNumber() {        return this.number;    }    private final CtrlCall call;    private final CtrlGuard guard;    private final Recipe recipe;    private final boolean start;    private final int number;}