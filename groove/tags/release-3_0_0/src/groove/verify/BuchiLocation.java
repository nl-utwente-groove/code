/* GROOVE: GRaphs for Object Oriented VErification * Copyright 2003--2007 University of Twente * * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,  * either express or implied. See the License for the specific  * language governing permissions and limitations under the License. * * $Id: BuchiLocation.java,v 1.4 2008-02-22 13:02:44 rensink Exp $ */package groove.verify;import groove.control.Location;import groove.explore.util.LocationCache;import groove.lts.GraphState;import groove.trans.Rule;import java.util.HashSet;import java.util.Set;/** * Interface representing the location of an automata * modelling temporal formulae. *  * @author Harmen Kastenberg * @version $Revision: 1.4 $ $Date: 2008-02-22 13:02:44 $ */
public class BuchiLocation implements Location {	public BuchiLocation() {		this(false);	}	public BuchiLocation(boolean accepting) {		this.accepting = accepting;		this.locationCount = getBuchiCount();	}	public Set<BuchiTransition> outTransitions() {		return transitions;	}//	@Override//	public Collection<? extends Location> getTargets(Rule rule, ExploreCache cache) {//		Set<BuchiLocation> result = new HashSet<BuchiLocation>();//		if (cache instanceof LocationCache) {//			LocationCache lCache = (LocationCache) cache;//			Collection<Rule> matchedRules = lCache.getMatched();//			for (PropertyTransition nextTransition: outTransitions()) {//				if (ModelChecking.isPropertyTransitionEnabled(nextTransition, matchedRules)) {//					result.add(nextTransition.getTargetLocation());//				}//			}//		} else if (cache instanceof PriorityLocationCache) {//			PriorityLocationCache plCache = (PriorityLocationCache) cache;//		}//		return result;//	}	public LocationCache createCache() {		// TODO Auto-generated method stub		return null;	}	public Location getTarget(Rule rule, LocationCache cache) {		// TODO Auto-generated method stub		return null;	}	public Set<Rule> moreRules(LocationCache cache) {		// TODO Auto-generated method stub		return null;	}	/**	 * @return	 */	public boolean isSuccess(GraphState state) {		return accepting;	}	public void addTransition(BuchiTransition transition) {		if (transitions == null) {			transitions = new HashSet<BuchiTransition>();		}		transitions.add(transition);	}	public void setAccepting() {		this.accepting = true;	}	@Override	public String toString() {		if (locationCount != -1) {			return "b" + locationCount;		} else {			return "b??";		}	}	public int getBuchiCount() {		return BUCHI_COUNT++;	}	private boolean accepting;	private Set<BuchiTransition> transitions;	private int locationCount;	public static int BUCHI_COUNT = 0;}
